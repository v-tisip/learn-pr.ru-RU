Ниже представлен типичный рабочий процесс для приложений, использующих хранилище BLOB-объектов Azure.

1. **Получение конфигурации**. При запуске загружается конфигурация, например строка подключения с ключом учетной записи. Это необходимо для проверки подлинности вызовов API.
1. **Инициализация клиента**. Клиентская библиотека службы хранилища Azure инициализируется с помощью строки подключения. При этом создаются объекты, которые приложение будет использовать для работы с API хранилища BLOB-объектов.
1. **Использование**. С помощью клиентской библиотеки выполняются вызовы API для работы с контейнерами и BLOB-объектами.

## <a name="configure-your-connection-string"></a>Настройка строки подключения

Перед написанием кода вам потребуется строка подключения для используемой учетной записи хранения. 

Она включает в себя ваш ключ учетной записи. Ключ учетной записи считается секретным и должен храниться в надежном месте. Мы будем хранить строку подключения в параметре приложения службы приложений. Параметр приложения — надежное место для секретов приложения, но он не поддерживает локальную разработку и не способен решить все задачи.

> [!WARNING]
> **Не включайте ключи учетных записей хранения в код или в незащищенные файлы конфигурации.** Ключ учетной записи предоставляет полный доступ к учетной записи хранения. Его утечка может привести к неустранимым повреждениям и финансовым потерям. Рекомендации по хранению ключей и действиям в случае их утечки см. в разделе "Дополнительные ресурсы" в конце этого модуля.

## <a name="initialize-the-blob-storage-object-model"></a>Инициализация объектной модели хранилища BLOB-объектов

В SDK службы хранилища Azure для .NET Core стандартная схема использования хранилища BLOB-объектов состоит из перечисленных ниже шагов.

1. Вызовите `CloudStorageAccount.Parse` (или `TryParse`) со строкой подключения, чтобы получить `CloudStorageAccount`.
1. Вызовите метод `CreateCloudBlobClient` класса `CloudStorageAccount`, чтобы получить `CloudBlobClient`.
1. Вызовите метод `GetContainerReference` класса `CloudBlobClient`, чтобы получить `CloudBlobContainer`.
1. Используйте методы контейнера, чтобы получить список BLOB-объектов или ссылки на отдельные BLOB-объекты для отправки и скачивания данных.

В коде шаги 1&ndash;3 выглядят так:

```csharp
CloudStorageAccount storageAccount = CloudStorageAccount.Parse(connectionString); // or TryParse()
CloudBlobClient blobClient = storageAccount.CreateCloudBlobClient();
CloudBlobContainer container = blobClient.GetContainerReference(containerName);
```

В этом коде инициализации вызовы по сети не совершаются. Это означает, что исключения из-за неправильных данных на этом этапе создаваться не будут. Например, вызов `GetContainerReference` будет выполнен успешно вне зависимости от того, существует ли контейнер в учетной записи.

## <a name="create-containers-at-startup"></a>Создание контейнеров при запуске

Как правило, контейнеры создаются приложениями в коде, даже если мы заранее знаем, какие контейнеры требуются. Лучше всего это делать с помощью вызова метода `CreateIfNotExistsAsync` класса `CloudBlobContainer`. С помощью этого метода следует создать каждый требуемый контейнер, прежде чем использовать его.

Метод `CreateIfNotExistsAsync` *выполняет* вызов службы хранилища Azure по сети. Рекомендуется совершать этот вызов один раз при запуске, а не каждый раз при обращении к контейнеру.

## <a name="exercise"></a>Упражнение

### <a name="clone-and-explore-the-unfinished-app"></a>Клонирование и изучение незавершенного приложения

Сначала клонируем простейшее приложение из GitHub. В терминале Cloud Shell выполните следующую команду, чтобы получить копию исходного кода и открыть ее в редакторе:

```console
git clone TODO
cd TODO
code .
```

Откройте файл `Controllers/FilesController.cs`.

Этот контроллер реализует интерфейс API с тремя действиями:

* **Index** (GET /api/Files) возвращает список URL-адресов, по одному для каждого отправленного файла. Интерфейсная часть приложения вызывает этот метод для формирования списка гиперссылок на отправленные файлы.
* **Upload** (POST /api/Files) получает отправленный файл и сохраняет его.
* **Download** (GET /api/Files/{имя-файла}) скачивает отдельный файл по его имени.

Для выполнения работы каждый метод вызывает экземпляр `IStorage` с именем `storage`. В файле `Models/BlobStorage.cs` имеется неполная реализация `IStorage`.

### <a name="add-the-nuget-package"></a>Добавление пакета NuGet

Сначала добавьте ссылку на SDK службы хранилища Azure. В терминале выполните следующие команды:

```console
dotnet add package WindowsAzure.Storage
dotnet restore
```

Таким образом гарантируется использование последней версии клиентской библиотеки хранилища BLOB-объектов.

### <a name="configure"></a>Настройка

Наше простейшее приложение уже включает в себя необходимые конфигурационные данные. Параметр конструктора `IOptions<AzureStorageConfig>` в `BlobStorage` имеет два свойства: строку подключения к учетной записи хранения и имя контейнера, в котором приложение будет хранить BLOB-объекты. В методе `ConfigureServices` в файле `Startup.cs` есть код, загружающий значения из конфигурации при запуске приложения.

В этом упражнении мы запустим приложение в Службе приложений Azure, поэтому позднее мы добавим значения конфигурации в параметры приложения службы приложений. Пока же не требуется выполнять никаких действий, связанных с конфигурацией.

### <a name="initialize"></a>Инициализация

Откройте `BlobStorage.cs`.

Найдите метод `Initialize`. Наше приложение вызовет его при первом использовании. Если вам интересно, вы можете изучить `ConfigureServices` в файле `Startup.cs`, чтобы понять, как это делается. 

Именно в методе `Initialize` создается контейнер, если он еще не существует. Заполните метод `Initialize` следующим кодом и сохраните результаты работы:

```csharp
public Task Initialize()
{
    CloudStorageAccount storageAccount = CloudStorageAccount.Parse(storageConfig.ConnectionString);
    CloudBlobClient blobClient = storageAccount.CreateCloudBlobClient();
    CloudBlobContainer container = blobClient.GetContainerReference(storageConfig.FileContainerName);
    return container.CreateIfNotExistsAsync();
}
```